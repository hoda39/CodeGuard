// src/core/casr.ts
import { spawn } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import { promisify } from 'util';
import { mapVulnerability, extractVulnerableVariable } from './vulnerability-mapper';

const unlink = promisify(fs.unlink);
const writeFile = promisify(fs.writeFile);
const readFile = promisify(fs.readFile);
const mkdtemp = promisify(fs.mkdtemp);
const copyFile = promisify(fs.copyFile);
const rm = promisify(fs.rm);

interface CancellationToken {
  isCancellationRequested: boolean;
  onCancel(callback: () => void): void;
}

/**
 * Runs CASR analysis for multiple sanitizers, handles UBSAN directory output.
 * Collects all .casrep and .json files generated by CASR-UBSAN.
 */
export async function runWithCasr(
  executablePath: string,
  inputFile: string,
  sanitizerTypes: ('asan' | 'ubsan' | 'msan')[] = ['asan', 'ubsan', 'msan'],
  cancellationToken?: CancellationToken
): Promise<any[]> {
  const reports: any[] = [];
  const reportDir = process.env.CASR_REPORT_DIR || path.dirname(executablePath);
  const baseName = path.basename(executablePath, path.extname(executablePath));

  for (const sanitizerType of sanitizerTypes) {
    if (process.env[`ENABLE_${sanitizerType.toUpperCase()}`] !== '1') continue;

    try {
      if (sanitizerType === 'ubsan') {
        // Setup temp input dir
        const tempInputDir = await mkdtemp(path.join(os.tmpdir(), 'casr-ubsan-'));
        await copyFile(inputFile, path.join(tempInputDir, path.basename(inputFile)));
        const outputDir = path.join(reportDir, `${baseName}_${sanitizerType}_analysis`);

        // Run casr-ubsan
        await new Promise<void>((res, rej) => {
          const proc = spawn(
            process.env.CASR_UBSAN_PATH || 'casr-ubsan',
            ['-i', tempInputDir, '-o', outputDir, '--', executablePath, '@@'],
            { cwd: path.dirname(executablePath), env: { ...process.env, UBSAN_OPTIONS: 'print_stacktrace=1:recover=1:halt_on_error=0' } }
          );
          if (cancellationToken) cancellationToken.onCancel(() => { proc.kill(); rej(new Error('cancel')); });
          proc.on('close', code => code === 0 ? res() : rej(new Error(`casr-ubsan ${code}`)));
        });

        // Read all CASR output files (.casrep or .json)
        const files = await fs.promises.readdir(outputDir);
        const casrFiles = files.filter(f => f.endsWith('.json') || f.endsWith('.casrep'));
        for (const fname of casrFiles) {
          if (fname.length) {
            const main = path.join(outputDir, fname);
            const data = await readFile(main, 'utf8');
            const rpt = JSON.parse(data);
            // enhance inline
            const vulnType = rpt.CrashSeverity?.ShortDescription || 'Unknown';
            rpt.VulnerabilityMapping = mapVulnerability(vulnType);
            rpt.cweId = `CWE-${rpt.VulnerabilityMapping.cweId}`;
            rpt.VulnerableVariable = extractVulnerableVariable(rpt);
            rpt.sanitizerType = sanitizerType;
            reports.push(rpt);
          }
        }

        // Cleanup
        await rm(outputDir, { recursive: true, force: true });
        await rm(tempInputDir, { recursive: true, force: true });
      } else if(sanitizerType === 'msan') {
        const casrPath = process.env.CASR_SAN_PATH!;
        const outJson = path.join(reportDir, `${baseName}_${sanitizerType}.json`);
            
        // Run CASR (MSAN)
        await new Promise<void>((res, rej) => {
          const env = {
            ...process.env,
            MSAN_OPTIONS: [
              'halt_on_error=1',       // stop at first error
              'abort_on_error=1',      // turn it into a crash
              'print_stacktrace=1'     // include a backtrace
            ].join(':')
          };
          const proc = spawn(casrPath, ['-o', outJson, '--', executablePath, inputFile], { env });
          cancellationToken?.onCancel(() => { proc.kill(); rej(new Error('cancel')); });
          proc.on('close', code => code === 0 ? res() : rej(new Error(`casr-san ${code}`)));
        });
      
        // Try JSON, otherwise fall back to .casrep
        let text: string;
        try {
          text = await fs.promises.readFile(outJson, 'utf8');
        } catch {
          // look for .casrep instead
          const casrep = outJson.replace(/\.json$/, '.casrep');
          text = await fs.promises.readFile(casrep, 'utf8');
        }
      
        const raw = JSON.parse(text);
        const rpt: any = {
          sanitizerType,
          CrashSeverity: raw.CrashSeverity,
          Stacktrace:    raw.Stacktrace,
          CrashLine:     raw.CrashLine,
          Source:        raw.Source,
          VulnerabilityMapping: mapVulnerability(raw.CrashSeverity.ShortDescription),
          cweId:         `CWE-${mapVulnerability(raw.CrashSeverity.ShortDescription).cweId}`,
          VulnerableVariable:  extractVulnerableVariable(raw)
        };
        reports.push(rpt);
      
        // clean up both possible files
        await Promise.all([
          unlink(outJson).catch(() => {}),
          unlink(outJson.replace(/\.json$/, '.casrep')).catch(() => {})
        ]);
      } else {
        // ASAN
        const casrPath = process.env.CASR_SAN_PATH || 'casr-san';
        const outJson = path.join(reportDir, `${baseName}_${sanitizerType}.json`);
        await new Promise<void>((res, rej) => {
          const proc = spawn(casrPath, ['-o', outJson, '--', executablePath, inputFile],
            { cwd: path.dirname(executablePath), env: { ...process.env, ASAN_OPTIONS: 'halt_on_error=0:abort_on_error=0:allow_multiple_errors=1:print_stacktrace=1' } }
          );
          if (cancellationToken) cancellationToken.onCancel(() => { proc.kill(); rej(new Error('cancel')); });
          proc.on('close', code => code === 0 ? res() : rej(new Error(`casr-san ${code}`)));
        });

        const data = await readFile(outJson, 'utf8');
        const rpt = JSON.parse(data);
        // enhance inline
        const vulnType = rpt.CrashSeverity?.ShortDescription || 'Unknown';
        rpt.VulnerabilityMapping = mapVulnerability(vulnType);
        rpt.cweId = `CWE-${rpt.VulnerabilityMapping.cweId}`;
        rpt.VulnerableVariable = extractVulnerableVariable(rpt);
        rpt.sanitizerType = sanitizerType;
        reports.push(rpt);
        await unlink(outJson).catch(() => {});
      }
    } catch (err) {
      console.error(`CASR ${sanitizerType} analysis failed:`, err);
    }
  }

  return reports;
}
